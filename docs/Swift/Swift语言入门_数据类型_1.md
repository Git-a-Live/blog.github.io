## 一、类和结构体

Swift语言中有**类**和**结构体**这两种重要的数据类型，按照官方文档的说法，类和结构体具有以下共同点：

```
· 定义属性用于存储值
· 定义方法用于提供功能
· 定义下标操作用于通过下标语法访问它们的值
· 定义构造器用于设置初始值
· 通过扩展以增加默认实现之外的功能
· 遵循协议以提供某种标准功能
```

两者的定义语法相似：

```
结构体：
struct DemoStruct {
    //TODO
}

类：
class DemoClass {
    //TODO
}
```

实例化语法也同样类似：

```
let demo1 = DemoStruct()
lwt demo2 = DemoClass()
```

在用法上，结构体和其他高级语言中的类差别不大，都是以`.`调用相关的属性和方法。

官方在何时使用结构体，何时使用类的问题上面提供了这样的基本原则：

```
如果需要使用继承特性和引用语义，那么就选择使用类。
```

所谓**引用语义**，是和**值语义**相对应的一种概念。
`引用语义`表示一个对象被系统标准的复制方式复制后，与被复制的对象之间依然*共享底层资源*，对其中一个的改变都将影响到另外一个；
`值语义`表示一个对象被系统标准的复制方式复制之后，与被复制的对象之间*毫无关系*，彼此独立改变且互不影响。

在Swift中，结构体对应的是使用值语义的**值类型**，而类则对应使用引用语义的**引用类型**。

## 二、属性

按照官方文档的说法：

```
属性将值与特定的类、结构体或枚举关联。
存储属性会将常量和变量存储为实例的一部分，而计算属性则是直接计算（而不是存储）值。
计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体。
```

与Java类似，Swift和Kotlin都可以自定义getter和setter，但是Swift还可以定义willSet和didSet两类方法，作为“***属性观察器***”。所谓的属性观察器，可以用来**监控属性值的变化，以此来触发自定义的操作**。属性观察器可以添加到类本身定义的存储属性上，也可以添加到从父类继承的属性上。

Swift使用self来指定当前实例内部定义的变量、常量乃至方法，与之相对，Kotlin使用this。

## 三、函数与方法

### 函数

函数是一段完成特定任务的**独立代码片段**。Swift中，一个函数的基本结构如下：

```
完整结构：
func 函数名(标签 参数: 参数类型) -> 返回类型 {
    //TODO
}

无输入参数：
func 函数名() -> 返回类型 {
    //TODO
}

无返回类型：
func 函数名() {
    //TODO
}
```

参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。事实上，在Java或者Kotlin等语言中，也有类似的机制用于提示开发者当前需要输入什么参数。

注意，**只要有一个参数使用了标签，其他参数也要跟随使用明确的标签或以`_`代替之**。

与Swift类似，Kotlin定义函数的基本结构如下：

```
完整结构：
fun 函数名(参数: 参数类型): 返回类型 {
    //TODO
}

无输入参数：
fun 函数名(): 返回类型 {
    //TODO
}

无返回类型：
fun 函数名() {
    //TODO
}
```

在**可变参数**方面，Swift和Kotlin也有类似的操作：

```
Swift：
func 函数名(标签 参数: 参数类型...) -> 返回类型 {
    //TODO
}

Kotlin:
fun 函数名(varrag 参数: 参数类型): 返回类型 {
    //TODO
}
```

无论是Swift还是Kotlin，对于每个函数而言，可变参数**只能定义一个**。此外，Swift的函数在定义可变参数时，需要添加标签，这样当不可变参数被定义在可变参数的后面时，调用过程中不会发生参数混淆从而出错（相当于使用标签作为分隔符）；Kotlin则需要强制将可变参数放在**最后定义**，以避免参数混淆。

### 方法

方法是与**某些特定类型相关联**的函数。类、结构体、枚举都可以定义专门为给定类型的实例封装具体的任务与功能的实例方法；类、结构体、枚举也可以定义与类型本身相关联的类型方法。

实例方法在Swift和Kotlin中所指代的含义基本相同，类型方法则类似于Java中静态方法的概念，**不需要实例即可直接调用**。

定义类型方法和定义函数一样，只不过是在某个具体的类、结构体或枚举里面操作；定义类型方法则有较大差异：

```
Java:
class Demo {
    public static ReturnType method(ParamType param){
        //TODO
    }
}

Swift:
class Demo {
    static func method1(param: ParamType) -> ReturnType {
        //TODO
    }

    class func method2(param: ParamType) -> ReturnType {
        //TODO
    }
}

Kotlin:
object Demo {
    fun function(param: ParamType): ReturnType {
        //TODO
    }
}

class Demo {
    companion object{
        fun function(param: ParamType): ReturnType {
            //TODO
        }
    }
}
```

注意，Swift语言除了使用static修饰方法从而使该方法可以直接调用外，还可以使用class来修饰，从而**允许该方法可被子类所重写**。

Kotlin同样有两种方式来实现类型方法，一种是将某个类直接以`object`取代`class`，其效果等同于**在Java中该类所包含的所有变量、常量以及方法均以**`public static`**修饰**；另一种则是**把可以直接调用的函数，连同它所使用到的变量、常量以及其他函数均放入**`companion object {}`**所包裹的代码块中**。





