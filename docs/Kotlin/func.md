函数式编程（Functional Programming）是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数称之为**没有副作用**。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导<font color=red>利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算</font>，而不是设计一个复杂的执行过程。

Kotlin是一门从一开始就支持函数式编程的语言，主要包括以下特性：

1. 支持函数类型，允许函数接收其他函数作为参数，或返回其他函数；
2. 支持lambda表达式，用最少的样板代码方便地传递代码块；
3. 数据类，提供了创建不可变数据对象的简明语法；
4. 标准库中提供丰富的函数式API，可用函数式编程风格操作对象和集合。

## Lambda表达式

Lambda表达式本质上是**可以传递给其它函数的一小段代码**。有了Lambda，可以轻松地把通用代码结构抽取成库函数。Lambda最常见的用途是和集合一起配合。

在Kotlin中，完整的Lambda表达式语法结构如下：

```
{arg1: Type1, arg2: Type2, ··· -> function body}
```

函数体内<u>最后一行代码会自动作为返回值</u>，通常不建议在函数体部分编写太多太长的代码（最好能整合成函数调用），否则可能会影响代码的可读性。

Kotlin对于Lambda的使用有以下规定：

+ Lambda表达式的参数通常可以**不声明类型**；
+ 在调用可接收Lambda表达式的函数时，可以直接传入表达式；
+ 若Lambda表达式是函数的**最后**一个参数，可将其放在函数括号之外；
+ 若Lambda表达式是函数的**唯一**一个参数，可将函数括号去掉；
+ 若Lambda表达式中只有一个参数，可以不声明其名称，而是用`it`来代替。

最典型的例子就是在Kotlin开发情况下，Android控件Button监听点击动作：

```
button.setOnClickListener {
    //TODO
}
```

## 常用函数式API

### 集合

前文已经提到，Lambda表达式经常同集合搭配使用，这意味着集合类中有大量的函数式API可供调用，下面列出了一些常见的API。

+ **filter**：遍历集合并选出应用给定的Lambda表达式后会返回true的那些元素。
+ **map**：对集合中的每一个元素应用给定的Lambda表达式并把结果收集到一个新集合。
+ **reduce**：将一个集合的所有元素通过传入的操作函数实现数据集合的累积操作效果。
+ **all**：集合中是否对每个元素执行给定的lambda表达式，都返回true。
+ **any**：集合中是否存在某个元素，对其执行给定的Lambda表达式返回true。
+ **count**：对集合中每个元素执行给定的Lambda表达式，返回true的元素数量。
+ **find**：返回集合中第一个执行给定lambda表达式结果为true的元素，如果没有就返回null。
+ **maxBy / minBy**：找到集合中的极值元素。
+ **groupBy**：按照给定的Lambda表达式，将集合分类为多个子集并返回一个Map，key是分类依据，value是该分类的元素List。
+ **flatMap**：使用传入的Lambda表达式对集合中每个元素做变换（映射），然后把多个列表合并成一个列表。

### Kotlin标准函数

Kotlin标准函数是指在Standar.kt文件中定义的函数，任何Kotlin代码都能自由调用所有的标准函数。下面列出了一些常用的标准函数及其基本用法。

+ **let**

`let`函数经常和`?.`操作符搭配使用，用于辅助判空处理，避免空指针异常：

```
val value = obj?.let { 
    //TODO
}
```

上述示例代码的含义为先判断obj是否为空，不为空则执行`let`内的业务逻辑，为空就不做任何操作。<font color=red>对象非空才有操作，以及对象是个全局变量、有被其他线程修改的风险时，推荐使用`let`而非单个if语句。</font>

+ **also**

`also`函数在用法上和`let`函数基本一样，但是它只返回调用的对象本身：

```
obj?.also { 
    //TODO
}
```

+ **with**

`with`函数可以连续调用同一对象的多个方法，使得代码变得精简：

```
val value = with(obj) {
    //业务逻辑（obj的方法调用）
}
```

+ **run**

`run`函数的使用场景和`with`函数类似，但是它需要通过一个对象来调用：

```
val value = obj.run {
    //业务逻辑（obj的方法调用）
}
```

+ **apply**

`apply`函数在使用上与`run`极其类似，但是它**无法指定返回值**，只会自动返回调用对象本身：

```
obj.apply {
    //业务逻辑（obj的方法调用）
}
```

+ **takeIf / takeUnless**：

由于`takeUnless`函数只是在逻辑上与`takeIf`函数相反，因此这里只介绍`takeIf`函数。`takeIf`函数通过对象来调用，传入一个条件进行判断，如果对象符合条件则返回自身，反之则返回`null`：

```
val value = obj?.takeIf {
    //TODO
}
```

+ **repeat**：

`repeat`函数用于重复执行某些代码，不需要依赖对象的调用，在使用时，需要传入执行次数和Lambda表达式：

```
repeat(times) {
    //TODO
}
```

## 高阶函数



## DSL