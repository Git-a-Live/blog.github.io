函数式编程（Functional Programming）是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数称之为**没有副作用***（无状态）。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用（有状态）的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导<font color=red>利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算</font>，而不是设计一个复杂的执行过程。

Kotlin是一门从一开始就支持函数式编程的语言，主要包括以下特性：

1. 支持函数类型，允许函数接收其他函数作为参数，或返回其他函数；
2. 支持lambda表达式，用最少的样板代码方便地传递代码块；
3. 数据类，提供了创建不可变数据对象的简明语法；
4. 标准库中提供丰富的函数式API，可用函数式编程风格操作对象和集合。

## Lambda表达式

Lambda表达式本质上是**可以传递给其它函数的一小段代码**。有了Lambda，可以轻松地把通用代码结构抽取成库函数。Lambda最常见的用途是和集合一起配合。

在Kotlin中，完整的Lambda表达式语法结构如下：

```
{arg1: Type1, arg2: Type2, ··· -> function body}
```

函数体内<u>最后一行代码会自动作为返回值</u>，通常不建议在函数体部分编写太多太长的代码（最好能整合成函数调用），否则可能会影响代码的可读性。

Kotlin对于Lambda的使用有以下规定：

+ Lambda表达式的参数通常可以**不声明类型**；
+ 在调用可接收Lambda表达式的函数时，可以直接传入表达式；
+ 若Lambda表达式是函数的**最后**一个参数，可将其放在函数括号之外；
+ 若Lambda表达式是函数的**唯一**一个参数，可将函数括号去掉；
+ 若Lambda表达式中只有一个参数，可以不声明其名称，而是用`it`来代替。

最典型的例子就是在Kotlin开发情况下，Android控件Button监听点击动作：

```
button.setOnClickListener {
    //TODO
}
```

## 常用函数式API

### 集合

前文已经提到，Lambda表达式经常同集合搭配使用，这意味着集合类中有大量的函数式API可供调用，下面列出了一些常见的API。

+ **filter**：遍历集合并选出应用给定的Lambda表达式后会返回true的那些元素。
+ **map**：对集合中的每一个元素应用给定的Lambda表达式并把结果收集到一个新集合。
+ **reduce**：将一个集合的所有元素通过传入的操作函数实现数据集合的累积操作效果。
+ **all**：集合中是否对每个元素执行给定的lambda表达式，都返回true。
+ **any**：集合中是否存在某个元素，对其执行给定的Lambda表达式返回true。
+ **count**：对集合中每个元素执行给定的Lambda表达式，返回true的元素数量。
+ **find**：返回集合中第一个执行给定lambda表达式结果为true的元素，如果没有就返回null。
+ **maxBy / minBy**：找到集合中的极值元素。
+ **groupBy**：按照给定的Lambda表达式，将集合分类为多个子集并返回一个Map，key是分类依据，value是该分类的元素List。
+ **flatMap**：使用传入的Lambda表达式对集合中每个元素做变换（映射），然后把多个列表合并成一个列表。

### Kotlin标准函数

Kotlin标准函数是指在Standar.kt文件中定义的函数，任何Kotlin代码都能自由调用所有的标准函数。下面列出了一些常用的标准函数及其基本用法。

+ **let**

`let`函数经常和`?.`操作符搭配使用，用于辅助判空处理，避免空指针异常：

```
val value = obj?.let { 
    //TODO
}
```

上述示例代码的含义为先判断obj是否为空，不为空则执行`let`内的业务逻辑，为空就不做任何操作。<font color=red>对象非空才有操作，以及对象是个全局变量、有被其他线程修改的风险时，推荐使用`let`而非单个if语句。</font>

+ **also**

`also`函数在用法上和`let`函数基本一样，但是它只返回调用的对象本身：

```
obj?.also { 
    //TODO
}
```

+ **with**

`with`函数可以连续调用同一对象的多个方法，使得代码变得精简：

```
val value = with(obj) {
    //业务逻辑（obj的方法调用）
}
```

+ **run**

`run`函数的使用场景和`with`函数类似，但是它需要通过一个对象来调用：

```
val value = obj.run {
    //业务逻辑（obj的方法调用）
}
```

+ **apply**

`apply`函数在使用上与`run`极其类似，但是它**无法指定返回值**，只会自动返回调用对象本身：

```
obj.apply {
    //业务逻辑（obj的方法调用）
}
```

+ **takeIf / takeUnless**：

由于`takeUnless`函数只是在逻辑上与`takeIf`函数相反，因此这里只介绍`takeIf`函数。`takeIf`函数通过对象来调用，传入一个条件进行判断，如果对象符合条件则返回自身，反之则返回`null`：

```
val value = obj?.takeIf {
    //TODO
}
```

+ **repeat**：

`repeat`函数用于重复执行某些代码，不需要依赖对象的调用，在使用时，需要传入执行次数和Lambda表达式：

```
repeat(times) {
    //TODO
}
```

## 高阶函数

### 基本概念

高阶函数（Higher-order function）是一种以函数为参数或返回值的函数，因此可以想到，在前文所提到的各种函数式API，本身就是高阶函数。掌握高阶函数的用法可以编写自定义函数式API。

在Kotlin中，除了整型、字符型和布尔型等类型之外，还有一种“函数类型”。既然有函数类型，那么就会有函数类型的**对象**但是函数本身有各种各样的形式（比如参数个数、是否返回结果等），因此需要采用下面这种方法来描述函数类型：

```
(Type1, Type2, ···) -> Type
```

左边是各个传入参数的类型，右边是返回结果的类型，如果是不返回结果，那么可以将其类型定为`Unit`或者`Void`。很明显，这种描述方式可以囊括相当一部分具有相同输入输出类型、但名称不一样的函数。

>注意，<font color=red>函数本身不是对象，因此不能被传递</font>。

### 基本使用方式

高阶函数的主要作用是让作为参数或返回结果的函数类型对象来决定执行逻辑，从而输出不同的结果。就“替换执行逻辑”而言，高阶函数有点类似于设计模式中的[Strategy](DesignPattern/行为型设计模式?id=九、strategy)。

一个高阶函数的常见构造方式如下：

```
fun Foo(func: (Type1, Type2, ···) -> Type) {
    //TODO
}
```

之前提到过，函数本身不是对象，不能被传递，因此在调用高阶函数传入函数类型对象的时候，通常采用以下几种方式：

1. **Lambda表达式**

Lambda表达式本质上就是函数类型对象，正因如此，它才能被赋值给别的变量，或是以自身作为参数传入高阶函数使用。

2. **匿名函数**

顾名思义，匿名函数就是一种没有名称的函数，<u>其定义方式跟普通函数基本相同</u>，只不过不需要写函数名称。匿名函数和Lambda表达式一样，本质上也是函数类型对象。

3. **函数引用**

函数引用是一种将函数转化为函数类型对象的手段，其基本做法就是在作为参数的函数的名称前加上`::`。虽然这种手段的名字叫函数引用，但实际上是创建了一个与原来的函数具有相同功能的函数类型对象。

4. **成员引用**

成员引用和函数引用类似，但是在使用时更为复杂。以下是一段示例代码：

```
//包含待引用函数的类定义：
class Demo {
    fun foo(p1: Type1, p2: Type2, ···): Type {
        //TODO
    }
}

//采取成员引用的高阶函数定义：
fun func(f: KFunctionX<Demo, Type1, Type1, ···， Type>) {
    //TODO
}

//调用高阶函数：
func(Demo::foo)
```

可以看到，传入高阶函数的参数类型为`KFunctionX<>`，其中X是一个整数，代表被引用函数的参数类型数+返回值类型数，<>内依次设置被引用函数所在的类、被引用函数的参数类型以及被引用函数返回值的类型。

### 内联函数

无论采取哪种手段获取和传入函数类型对象，Kotlin都会将函数类型对象在底层转换为匿名类实例，然后在`invoke()`中实现真正的业务逻辑——这意味着每调用一次高阶函数，底层都会“new”一个对象实例出来，从而增加资源和性能开销。为了解决这一问题，Kotlin采用**内联函数**的机制，即<font color=red>Kotlin会将内联函数中的代码在编译时自动替换到调用它的地方</font>。

内联函数的用法非常简单，就是在定义好的高阶函数前用`inline`关键字进行修饰。如果只想内联一部分函数类型对象，那么就在不需要内联的函数类型参数前加上`noinline`进行修饰。

绝大多数高阶函数是可以且应当被修饰为内联函数，但在**使用了匿名类实现**的高阶函数中，由于匿名类实现与内联函数之间的冲突<font color=red>（匿名类实现不允许使用`return`，而内联函数的Lambda表达式允许使用该关键字）</font>，函数类型参数必须使用`crossinline`进行修饰，同时Lambda表达式中不能直接使用`return`，而是改用`return@内联函数名`。这样既能使用`return`实现局部返回，也能保留内联函数的其他所有特性。

## DSL

DSL（Domain Specific Language，领域特定语言）是一种**以极其高效的方式描述特定领域的对象、规则和运行方式的语言**，需要有特定的解释器与其配合。DSL可以让开发者编写出一些看似脱离其原始语法结构的代码，从而构建出一种专有的语法结构。DSL的一种典型应用就是Gradle文件导入依赖。

Kotlin支持DSL，并且实现方式也并不固定，最主要的有infix函数和高阶函数。

### infix函数实现DSL

infix函数是Kotlin提供的一种高级语法糖，它可以让开发者使用被称作“中缀表示法”的语法规则，亦即忽略调用的点`.`与圆括号`()`，类似于自然语言，即调用infix函数时，`A foo B`等同于`A.foo(B)`。最典型的应用就是Kotlin自带`mapOf()`函数中的`key to value`语法。

infix函数具有以下特点：

+ 必须是成员函数或[扩展函数]()；
+ 必须只有一个参数；
+ 其参数不得接受可变数量的参数且不能有默认值；
+ 调用优先级低于算术操作符、类型转换以及 rangeTo 操作符，但高于布尔操作符 && 与 ||、is- 与 in- 检测以及其他一些操作符。

infix函数的定义和普通函数的主要区别在于infix函数要使用`infix`关键字修饰，一些示例如下：

```
//infix修饰成员函数：
class Demo {
    infix fun foo(param: Params) {
        //TODO
    }
}

//infix修饰扩展函数：
infix fun K.foo(that: V): Type {
    //TODO
}
```

### 高阶函数实现DSL

使用高阶函数实现自定义DSL的场景、形式多种多样，限于篇幅不可能一一详解，但其核心思想是不变的：**利用高阶函数构建出一种简化语法并使用**。以Gradle导入依赖为例，Kotlin可以利用高阶函数构建出与[Groovy](Gradle/Groovy语言入门_基本语法.md)十分相似的DSL语句：

```
//Gradle Groovy DSL：
dependency {
    implementation '···'
}

//Gradle Kotlin DSL：
dependency {
    implementation("···")
}
```