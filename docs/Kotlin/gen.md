## 泛型

早在Java 1.5版本时期，泛型机制就已经被引入了。所谓泛型，其实就是一种“代码模板”，即可以用一套代码套用各种类型，实现了编写一次，万能匹配，又通过编译器保证了类型安全（避免不必要的强制转型）。

### 基本用法

+ **泛型类**

泛型类的基本定义方式为：

```
class DemoClass<T> {
    //TODO
}
```

在实例化某个泛型类时，可以采用以下方式：

```
val instance = DemoClass<SomeType>()
```

+ **泛型方法**

泛型方法的定义如下：

```
fun <T> foo(param: T): T {
    //TODO
}
```

>注意，泛型可以定义多种类型，如Map\<K,V>。

Kotlin允许开发者以`<T: BaseType>`的形式对泛型类型**上界**进行限制，例如`<T: Number>`就表示仅允许传入Int、Float以及Double等继承于Number基类的类型。此外，在默认情况下，所有的泛型都是都是可空（上界为`Any?`）的，如果想让泛型类型不可为空，就将上界修改为不带`?`的类型。

### 泛型实化

在了解什么是泛型实化之前，需要先了解Java中的“泛型擦除机制”。所谓“泛型擦拭”，是指Java的泛型由编译器在编译时实行，编译器内部始终把所有类型T视为Object处理，**在需要转型的时候，编译器才会根据T的类型自动实施安全的强制转型**。擦拭机制决定了所有基于JVM的语言都具有如下限制：

+ 泛型不能是基本类型；
+ 无法获取带泛型类型的Class；
+ 无法判断带泛型类型的类型；
+ 不能实例化T类型。

但是Kotlin将所有数据类型都改成了对象数据类型，于是绕开了第一条限制；通过[内联函数](Kotlin/func?id=内联函数)直接绕开了剩下的三个限制，这就是Kotlin泛型实化的实质和原理。

泛型实化的实现方法为：

```
inline fun <reified T> foo(param: ParamType): ReturnType {
    //在此处执行与类型T相关的操作
}
```

可以看到，泛型实化必须满足两大条件：内联函数和`reified`关键字修饰T类型。泛型实化之后，诸如`a is T`和`T::java.class`之类的语法就能用了。

### 协变与逆变

## 委托

### 原理

### lazy函数