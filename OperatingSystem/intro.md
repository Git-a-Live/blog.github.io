## 何为操作系统

操作系统（Operating System，OS）发展至今，还没办法给出一个准确的定义。想要理解操作系统到底是什么，往往需要从以下两个角度入手：

+ **<font color=red>向应用程序提供基本的抽象</font>**
+ **<font color=red>对计算机硬件进行资源管理</font>**

第一个角度是一种**自顶向下**的观点。通常情况下，在一个极其复杂的计算机设备上，应用程序很少会跟硬件直接打交道，因为硬件提供的接口往往是复杂和不一致的，一个应用程序想要适配成千上万种不同的硬件接口，显然是一种不可能的任务。因此在应用程序和硬件之间，必须存在一个充当“中间人”的角色，**隐藏底层硬件细节，为应用程序提供良好、清晰、优雅以及一致的抽象（比如系统API）**，这个角色就是操作系统。

第二种角度是一种**自底向上**的观点。从这个角度来说，操作系统的主要任务是**记录哪些应用程序在使用什么资源，对资源请求进行分配，评估使用代价，并为不同的应用程序和用户调解互相冲突的资源请求**。操作系统的资源管理往往采用<font color=red>时间复用</font>和<font color=red>空间复用</font>两种方式，来实现资源的多路复用（共享）。时间复用是指一项资源由不同的程序和用户轮流使用（比如CPU执行指令），空间复用则是指不同的程序和用户得到资源的一部分，从而不用进行排队等待（比如内存中有多个程序在运行）。

## 操作系统中的基本概念

### 内核态与用户态

内核态也称管态或核心态，是指操作系统对所有硬件具有完全访问权，可以执行机器能够运行的任何指令。内核态之外的状态就是用户态，即只能执行机器指令的一个子集，一般的应用程序都只能运行在用户态。

### 进程

进程（process）在本质上是一个**正在执行的程序**，也可以说是**容纳运行一个程序所需的全部信息的容器**。在许多操作系统中，还会维护一张记录有每个进程所有信息（地址空间除外）的**进程表**，这个表的数据结构是数组或链表。

系统管理器会为每一个被启动的程序赋予一个UID（User Identification）供程序使用，如果一个进程还创建了子进程，那么它们的UID是相同的。每个用户可以是某个组的成员，因此还会被赋予GID（Group Identification）。

### 地址空间

地址空间（address space）是一个集合（或列表），里面包含有从某个最小值到某个最大值的存储位置。在特定的地址空间中，程序可以进行读写，因此一个地址空间里面可能存放有可执行的程序、程序相关的数据以及程序堆栈等。地址空间同时也是一个逻辑概念，因为它可能涉及到内存和硬盘两种不同性质的物理存储空间。换言之，地址空间的总大小可能小于，也可能大于内存或硬盘中的任意一个。

### 文件

文件（file）是操作系统中一个极为重要的概念，它是对**存储当中特定格式的数据集合体**的一种高度抽象。这种抽象模型独立于任何硬件设备，操作系统能够隐藏硬盘以及其他I/O设备的细节特性，文件的抽象无疑是十分关键的一点。在访问文件时，如果用户具备访问权限，文件会返回一个被称作**文件描述符**（file descriptor）的小整数以供后续使用，否则系统会返回一个错误码。

#### 目录

目录（directory）是一个和文件紧密相关的概念，主要用于文件的分类保存。目前绝大多数操作系统都支持目录的概念。目录具有层次结构，它可以包含文件和其他的目录，这就构成了文件系统。目录层结构中的每一个文件，都可以通过从目录顶部的**根目录**（root directory）开始的**路径名**（path name）来确定。如果一个路径名是从根目录开始的，那么就称其为**绝对路径**，否则称为**相对路径**。

#### 安装文件系统

安装文件系统是UNIX系统中一个重要概念，其核心操作就是将可移动介质（如U盘）的文件系统接到**主文件树**上。可移动介质的文件系统通过`mount`这一系统调用方式，接入到计算机的**根文件系统**，这样就建立起从计算机根目录到可移动介质文件的访问路径。

#### 特殊文件

特殊文件（special file）是UNIX当中另一个重要概念。特殊文件往往保存在`/dev`目录中，由此可知，特殊文件跟I/O设备之间具有密切关系。事实上，特殊文件的作用就是让I/O设备看起来跟一般意义上的文件一样，能够被操作系统以相同的调用方式读写。

特殊文件被分为**块特殊文件**（block special file）和**字符特殊文件**（character special file）两种类型。前者是指<font color=red>由可随机存取的块所组成</font>的设备，比如磁盘等，程序在访问块数据时，可以不用考虑存放该文件的文件系统结构；后者用于打印机、调制解调器以及其他<font color=blue>接收或输出字符流</font>的设备。

#### 管道

管道（pipe）是一种虚文件，用于连接两个进程实施通信。如果两个进程希望通过管道进行通信，那么就必须要提前设置管道。数据发送一方需要将数据写入管道，数据接收方则需要读取管道。这样，通信双方之间的交互就类似于普通文件的读写了。

### 系统调用

顾名思义，系统调用就是操作系统提供API来实现某些功能，比如创建、删除以及读写文件等。系统调用在抽象层面上并不依赖于任何操作系统，但是具体的实现细节是跟操作系统相关的。系统调用提供的是系统服务，因此可以进入内核执行指令。

## 操作系统结构

### 单体系统

单体系统是指整个操作系统以过程集合方式编写，链接成一个大型的二进制可执行程序，在内核态以单一程序方式运行。这种结构的优点在于，系统中的每个过程可以自由高效地调用其他过程，但是缺点也很明显，这种不受限制的调用在数量较多的情况下会使得系统变得难以理解和维护，并且任何过程的崩溃都会连累整个操作系统。因此，单体系统结构只适合复杂度较低的情形。事实上，单体系统与其称之为系统，不如说就是一个直接安装在硬件上的简单程序。

### 层次式系统

层次式系统顾名思义就是将操作系统的功能从下往上划分成若干层次，除最底层外，上层软件都是在下层软件的基础上构建的。分层之后，各层都可以向上提供良好的抽象（API），屏蔽低层次的细节。层次结构的优点是解决了单体系统自由调用各种过程所带来的混乱，将调用限制在合理的范围以及方向，但是缺点也很明显：一方面，层次式系统依然是一个位于内核的单一程序，任意过程崩溃都会拖累整个系统；另一方面，设计者需要划分出内核-用户的边界，有些时候这并不是一件简单的事情。

### 微内核

微内核是一种设计思想，其主要内容是：为实现高可靠性，将操作系统划分为若干定义良好的小型模块，并且只有一个模块——微内核——运行在内核态，其余模块因为功能相对弱一些，作为普通用户进程运行。微内核摒弃了单体系统将所有功能都放在内核中运行的做法，降低了微内核模块复杂度，以及内核发生错误引发系统崩溃的可能性，从而提高系统的稳定性和可靠性。除此之外，微内核还采用了内核中**机制与策略相分离**的原则，使得系统内核更加小巧。所谓机制，通俗来说就是“做什么”，而策略就是指“怎么做”。

由于微内核以外的模块都运行在用户态，因此即便这些模块发生错误，也不会影响到运行在内核的微内核模块，自然也就不会拖累整个操作系统。微内核在实时、工业、航空以及军事等**对可靠性要求极高**的领域中流行，而桌面操作系统并不使用微内核。

> 实时操作系统分为硬实时操作系统和软实时操作系统两大类。前者要求某个动作必须在规定时间点活时间范围内执行，否则会产生严重后果；后者允许某个动作偶尔违反最终期限，并且这种违反也不会引起永久性损害。

### C/S模式

C/S模式可以视作微内核的一种变体。在这种模式下，进程被划分为客户端进程和服务器进程两种类型，前者使用服务，而后者提供服务。对客户端进程而言，要获得一个服务，需要构造一段消息，说明所需要的服务，然后发送给合适的服务器；对服务器进程而言，在接收到请求服务的消息之后完成工作，然后发送回应。

C/S模式并不在意客户端进程与服务器进程是否位于同一台设备上，因为不管是不是在同一台设备上，它们做的事情都是类似的：发送消息然后得到回应。C/S模式的典型应用就是网站。

