
早在Java 1.5版本时期，泛型机制就已经被引入了。所谓泛型，其实就是一种“代码模板”，即可以用一套代码套用各种类型，实现了编写一次，万能匹配，又通过编译器保证了类型安全（避免不必要的强制转型）。


## 泛型类

泛型类的基本定义方式为：

```
class DemoClass<T> {
    //TODO
}
```

在实例化某个泛型类时，可以采用以下方式：

```
val instance = DemoClass<SomeType>()
```

## 泛型方法

泛型方法的定义如下：

```
fun <T> foo(param: T): T {
    //TODO
}
```

>注意，泛型可以定义多种类型，如Map\<K,V>。

Kotlin允许开发者以`<T: BaseType>`的形式对泛型类型**上界**进行限制，例如`<T: Number>`就表示仅允许传入Int、Float以及Double等继承于Number基类的类型。此外，在默认情况下，所有的泛型都是都是可空（上界为`Any?`）的，如果想让泛型类型不可为空，就将上界修改为不带`?`的类型。

## 泛型实化

在了解什么是泛型实化之前，需要先了解Java中的“泛型擦除机制”。所谓“泛型擦拭”，是指Java的泛型由编译器在编译时实行，编译器内部始终把所有类型T视为Object处理，**在需要转型的时候，编译器才会根据T的类型自动实施安全的强制转型**。擦拭机制决定了所有基于JVM的语言都具有如下限制：

+ 泛型不能是基本类型；
+ 无法获取带泛型类型的Class；
+ 无法判断带泛型类型的类型；
+ 不能实例化T类型。

但是Kotlin将所有数据类型都改成了对象数据类型，于是绕开了第一条限制；通过[内联函数](Kotlin/func?id=内联函数)直接绕开了剩下的三个限制，这就是Kotlin泛型实化的实质和原理。

泛型实化的实现方法为：

```
inline fun <reified T> foo(param: ParamType): ReturnType {
    //在此处执行与类型T相关的操作
}
```

可以看到，泛型实化必须满足两大条件：内联函数和`reified`关键字修饰T类型。泛型实化之后，诸如`a is T`和`T::java.class`之类的语法就能用了。

## 协变与逆变

协变和逆变，本质上都是用来**描述类型转换后的继承关系**。所谓协变，是指<font color=red>某个类型（基类）可以由其派生类型（子类）安全地替换</font>，而逆变则表示<font color=blue>某个类型（子类）可以被安全地替换成其所继承的基类</font>。举个例子，若A是B的子类，同时Demo\<A>也是Demo\<B>的子类，那么就称Demo在T类型上支持协变；反之，若A是B的子类，但Demo\<B>是Demo\<A>的子类，那么就称Demo在T类型上支持逆变。在实际的使用中应当遵守这样一个原则：<font color=orange>让泛型在协变时只出现在返回值位置（即只读不写），在逆变时只出现在参数位（即只写不读）。</font>

>注意，虽然Kotlin提供了`@UnsafeVariance`注解来突破上述原则，但是绝不能滥用。

Kotlin使用`out`关键字修饰泛型，亦即采用`<out T>`的方式来声明一个协变的泛型；逆变则使用`in`关键字修饰泛型，声明时采用`<in T>`的方式。而在Java中，声明一个泛型是协变的，需要使用通配符`<? extends T>`，逆变的泛型则使用通配符`<? super T>`（这里还引申出PECS原则，即返回T的Producer使用extends，写入T的Consumer使用super）。

**总而言之，协变的目的是为了确保泛型类型向下转型安全，而逆变则是为了确保泛型类型向上转型安全。**