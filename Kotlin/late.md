## 延迟初始化

在Java中，声明变量却没有马上赋值的情形有很多，尤其是使用全局变量的时候。没有马上赋值（即未初始化）的变量默认为`null`，在使用时需要做判空处理。对于追求空安全的Kotlin而言，未初始化的变量总是一个巨大的隐患，因而会迫使开发者在声明变量的同时必须初始化，或者允许该类型为空，然后在每个用到该变量的地方都做判空处理。

Kotlin还给出了另一种解决方案，那就是先用`lateinit`关键字来修饰变量，等到正式调用之前再进行赋值，从而实现初始化的延迟，并且不需要声明变量类型可为空，以确保空安全（前提是调用该变量之前确实已经赋过值了，否则还是会发生空异常）。

>注意，`lateinit`关键字只能跟`var`搭配，凡是以`val`声明的变量必须在声明的同时进行赋值。

## 扩展函数

扩展函数是指在不修改某个类的源码的情况下，仍然可以向该类添加的新函数，这就是“扩展”含义的由来。扩展函数在很多情况下可以让API变得更加简洁、丰富和面向对象，尤其是一些不可继承类，利用扩展函数可以在不修改源码的前提下扩充它们的API。

扩展函数的定义语法如下：

```
fun ClassName.methodName(param: ParamType): ReturnType {
    //TODO
}
```

相比于定义一个普通函数，定义扩展函数只需要在函数名前加上`类名.`的语法结构，就表示将该函数添加到指定类（任何类都可以）中了。上述代码中的`ClassName`部分被称为Receiver（接收器），Receiver在扩展函数中可以用`this`直接调用。扩展函数可以定义在任意一个现有类当中，不一定要像Java那样新创建一个文件，同时最好将扩展函数定义成顶层方法，以使其拥有全局访问域。

## 密封类

在Kotlin中使用`when`语句时，通常需要编写`else`分支以满足编译器的语法检查，但是这有两个问题：一是其他分支已经包含所有的状态情况了，`else`分支是多余的；二是新增状态情况时，如果忘记在`when`中添加指定分支语句，那么就会默认走`else`分支，可能无法满足需要。为了解决这一问题，Kotlin使用了密封类机制。

所谓密封类，是指在声明一个可继承类时用`sealed`关键字来修饰，同时继承该父类的所有子类都**必须和父类位于同一个文件的顶层位置**。在将密封类传入`when`语句时，编译器会自动检查该密封类下有哪些子类，并强制要求开发者将每一个子类所对应的情况一一处理，这样即使没有编写`else`分支，也不会发生漏写条件的情况。