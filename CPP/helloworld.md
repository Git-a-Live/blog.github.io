按照IT界的惯例，第一个程序是输出“Hello World”，这里自然也是继续遵循传统。但是要知道，“Hello World”的意义不仅仅是检测IDE、编译环境是否正常，它还提供了一些与程序相关的基本信息。

## 基本结构

下面是CLion创建的“Hello World”样例代码：

```
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

这个样例展示了C++程序最基本的结构：
+ 预处理器编译指令`#include`
+ 函数头`int main()`
+ 函数体
+ 结束main函数的return语句

乍一看C++程序的基本结构跟C语言好像没什么太大的区别，确实如此，毕竟都是C嘛！但是仔细观察就会发现两者的不同：首先，C++的预处理器编译指令导入的是`iostream`，而C语言是`stdio.h`；其次，C语言用`printf()`函数来打印，C++用的是`cout`，而且还采用了函数式引用。

事实上，更为常见的一种程序结构是这样的：

```
#include <iostream>

int main() {
    using namespace std;
    cout << "Hello, World!" << endl;
    return 0;
}
```

`using namespace std`是一个编译指令，用于声明**名称空间**。所谓名称空间是一项C++特性，类似于Java中的import。比如，一个程序里面存在两个隶属于不同库、但函数头完全一样的函数，这时候就需要在函数前面加上名称空间的前缀以示区分。就像上面的`cout`和`endl`一样，如果不加前缀或不声明为std，IDE就会提示代码有错误，因为此时IDE根本不知道`cout`和`endl`调用的是哪个库、哪个版本的函数。

假设有一个库名为example，它也包含`cout`和`endl`，为了在程序当中把它们与C++标准库的那两个区分开来，就需要这样做：

```
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    example::cout << "Hi, World!" << example::endl;
    return 0;
}
```

当然，如果是简单的程序，没有用到别的库，在通常情况下可以使用`using namespace std`来偷懒，这样就不必在每个函数前面都加上`std::`的前缀。

## 基本语法

### 声明变量

和C语言一样，C++的任何变量在使用前都必须声明，且务必确保格式为`类型+空格+变量名+其他语句+;`，否则IDE会捕捉到这一错误并予以提示：

```
int number;
string word;
```

对于变量名的命名，C++有以下规则：

+ 名称中仅包含字母、数字和下划线，且不能以数字开头
+ 区分大小写
+ 不能使用C++关键字作为名称
+ 以两个下划线，或者一个下划线+大写字母开头的变量名称被保留给编译器及其使用的资源，以一个下划线开头的变量名同样被保留用作全局标识符

至于命名风格，只要确保含义清晰、风格一致即可，最重要的是和开发团队保持一致。

### 变量赋值

绝大多数语言都使用`=`来对变量进行赋值，C++也不例外：

```
//方式一：
int number = 0;

//方式二：
int num1 = 1, num2 = 2, num3 = 3;

//方式三：
int num1, num2, num3;
num1 = num2 = num3 = 6;
```

注意到方式三里面，三个变量被连续赋值，此时的赋值顺序是从右往左。

### 输出语句

C++使用的是`std::cout`来输出打印，同样是打印，它比C语言的`printf()`函数更为智能，尤其是不需要指明要打印的变量是何种类型（这一特性来源于面向对象）。Java当中的`System.out.println()`也同样具备这样的特性。C++的`std::cout`通常有以下用法：

```
//方式一：
std::cout << "Hi" << std::endl;

//方式二：
int age = 20;
std::cout << "Alice is " << age << " years old" << std::endl;

//方式三：
int num1 = 0;
int num2 = 1;
int num3 = 2;
std::cout << "Three numbers: "
<< num1 << " , "
<< num2 << " , "
<< num3 << std::endl;
```

C++可以使用`std::cout`进行字符串拼接，这一特性与Java使用`+`拼接字符串一样。

这里注意到`std::cout`跟`std::endl`一起使用，后者用来换行，跟`\n`的效果是一样的。在通常情况下，如果想为一行字符串换行，使用`\n`可以减少输入量，而纯粹打印一行空行，用`std::endl`更为方便一点。

### 输入语句

C++使用`std::cin`来实现输入，与C语言的`scanf()`不同。它的常用方式为：

```
int age;
std::cout << "How old are you?" << std::endl;
std::cin >> age;
std::cout << "You're " << age << " years old now." << std::endl;
```

在某些情况下，C++程序被编译成`.exe`文件后一运行，控制台窗口仅仅在屏幕上一闪而过，这时候可以在程序的`return 0;`语句前加上一句`std::cin.get()`，之后再编译成`.exe`文件运行，控制台窗口便不会再出现这种情况。原因在于，`std::cin.get()`会等待用户的输入操作，只要控制台窗口执行到这一句就会处于等待状态，只有当用户按下任意按键进行输入时，后面的语句才会继续执行下去。除了`std::cin.get()`语句，`system("pause")`也有类似的作用。

### 循环语句

#### for循环

C++for循环语句的常用方式很简单：

```
for (int i = 0; i < some_value; i++) {
    //TODO: 循环执行若干次
}
```

和C语言一样，C++的for循环也是由这几个部分组成的：

+ 初始值`int i = 0`（初始值的赋值变量可以在外面声明）
+ 执行条件`i < some_value`
+ 步长`i++`（可以改得更大或者更小）
+ 循环体

从C++11开始，for循环新增了一个“基于范围”的特性，说得直接一点，就是和Java类似的增强型for循环（“Java不是基于C++发展而来的吗，怎么会有老子像儿子的说法？”“因为本人先学的Java。”）：

```
//只能遍历读取，不能修改
for(type t : some_range) {
    //TODO: 遍历某个具有迭代特性的对象，如数组等
}

//既能遍历读取，又能修改
for(type &t : some_range) {
    //TODO: &t是一个引用对象，因此可以进行修改
}
```

>注意，C++在引入面向对象特性的同时，还保留了C语言的指针，因此使用指针时必须非常小心。

#### while/do-while循环

C++的while循环常见使用方式如下：

```
while(some_condition) {
    //TODO: 当some_condition为真时循环执行
}
```

do-while循环跟C语言还是一样的：

```
do {
    //TODO: 当some_condition为真时循环执行
} while(some_condition)
```

值得注意的是，一些开发者使用空判断条件的for循环来代替while以执行一个死循环，并声称这在汇编层面更加简洁，然而这种做法并不具备普适性，**除非设备对于机器码的简洁程度高度敏感，否则没有任何必要把运用语言晦涩特性的优先级放在代码可读性之前**。

### 分支语句

#### if/if-else语句

许多高级语言都使用同样结构的if/if-else语句：

```
if(condition_is_true) {
    //TODO：满足本条件时执行
} else if(condition_is_true) {
    //TODO：不满足上一个条件但满足本条件时执行
} else {
    //TODO：上述条件都不满足时才会执行
}
```

C++还采用了三元运算符来简化只有两个分支的if语句：

```
type t = condition_is_true ? result_true : result_false;
```

其等效于

```
type t;
if(condition_is_true) {
    t = result_true;
} else {
    t = result_false;
}
```

当然，三元运算符并非只能像上面的例子那样简单地返回结果，它的两个分支还能执行一些更为复杂的语句，就像在普通的if-else当中所做的那样——只不过可读性方面会大打折扣。如果不怕被打的话，完全可以利用这一特性简化自己的代码。

#### switch-case语句

C++的switch-case语句使用起来也比较简单：

```
switch(expression) {
    case case_1: //TODO：符合case_1时执行 break;
    case case_2: //TODO：符合case_2时执行 break;
    case case_3:
    case case_4: //TODO：符合case_3或case_4时执行 break;
    ···
    default: //TODO：默认情况时执行
}
```

编写Java程序的switch-case语句并不需要额外添加break，因为默认就会break。但是C++毕竟还是从C演变过来的，不加break就会发生语句穿透（除非要利用这一特性）。此外，对于何时用switch-case，何时用if-else，一个常用的判断准则是：当选项类型超出**整型常量**的范围（比如判断一个值是否落在某个范围内）时，选用if-else；在if-else和switch-case都能使用的场景下，分支选项在**三个以上**时使用switch-case。

### 常用运算符

| 运算符 | 作用                                                                  |
| :----- | :-------------------------------------------------------------------- |
| +      | 加法运算                                                              |
| -      | 减法运算                                                              |
| *      | 除法运算                                                              |
| /      | 除法运算                                                              |
| %      | 求余运算                                                              |
| +=     | 左变量与右变量做加法后赋值给左变量，例如`a += b`等效于`a = a + b`     |
| -=     | 左变量与右变量做减法后赋值给左变量，例如`a -= b`等效于`a = a - b`     |
| *=     | 左变量与右变量做乘法后赋值给左变量，例如`a *= b`等效于`a = a * b`     |
| /=     | 左变量与右变量做除法后赋值给左变量，例如`a /= b`等效于`a = a / b`     |
| %=     | 左变量与右变量做求余运算后赋值给左变量，例如`a %= b`等效于`a = a % b` |
| ++     | 变量递增加1，例如`a ++`等效于`a = a + 1`                              |
| --     | 变量递减减1，例如`a --`等效于`a = a - 1`                              |
| ==     | 相等                                                                  |
| !=     | 不等                                                                  |
| >      | 大于                                                                  |
| <      | 小于                                                                  |
| >=     | 大于等于                                                              |
| <=     | 小于等于                                                              |
| &&     | 且                                                                    |
| \|\|   | 或                                                                    |
| !      | 非                                                                    |
| &      | 按位与                                                                |
| \|     | 按位或                                                                |
| ~      | 按位取反                                                              |
| ^      | 按位异或                                                              |
| <<     | 左移，相当于乘以2的若干次幂，例如`m << n`表示m×2<sup>n<sup>           |
| >>     | 右移，相当于除以2的若干次幂，例如`m >> n`表示m÷2<sup>n<sup>           |
| &=     | 运算后赋值给左变量                                                    |
| \|=    | 类似上面                                                              |
| ~=     | 类似上面                                                              |
| ^=     | 类似上面                                                              |
| <<=    | 类似上面                                                              |
| >>=    | 类似上面                                                              |

### 基本数据类型

#### 整型

| 类型       | 说明                                                        |
| :--------- | :---------------------------------------------------------- |
| short      | 长度至少 2 byte（16位）                                     |
| int        | 长度至少 2 byte（16位），通常为 4 byte（32位）              |
| long       | 长度至少 4 byte（32位）                                     |
| long long  | 长度至少 8 byte（64位）                                     |
| 无符号整型 | 将上述整型类型用`unsigned`修饰，长度不变，但范围从0开始计算 |

**C++支持以十进制、八进制以及十六进制的方式直接表示整数**，例如：

```
int a = 42; //十进制的42
int b = 0x42; //十六进制数，对应十进制的66
int c = 042; //八进制数。对应十进制的34
```

上面的这些示例如果用`std::cout`打印出来，都会以十进制的形式呈现；而无论采用何种进制，最终它们都会在底层被转换成二进制数。

#### 浮点数

| 类型        | 说明                              |
| :---------- | :-------------------------------- |
| float       | 至少 4 byte（32位），通常也是32位 |
| double      | 至少 6 byte（48位），通常是64位   |
| long double | 可能有80、96或128位，通常是128位  |

C++支持以下这些方式表示浮点数：

```
float f = 0.0;
double d = 0.0;
long double ld = 0.0;

std::cout << 1.2F << endl; //float类型的1.2
std::cout << 1.2E2 << endl; //double类型的120
std::cout << 1.2L << endl; //long double类型的1.2
std::cout << 1.23456E2F << endl; //float类型的123.456
std::cout << 1.23456E2L << endl; //long double类型的123.456
```

#### 字符类

| 类型          | 说明                                                                                                                                             |
| :------------ | :----------------------------------------------------------------------------------------------------------------------------------------------- |
| char          | 通常 1 byte（8位），使用单引号`'some_char'`表示单个字符，特殊字符需要进行转义，可存储标准ASCII字符                                               |
| signed char   | 存储范围从-128到127                                                                                                                              |
| unsigned char | 存储范围从0到255                                                                                                                                 |
| wchar_t       | 宽字符类型（如CJK字符），用于表示系统所使用的最大扩展字符集，长度由系统和IDE决定，通常用`wcin`和`wcout`处理，普通的`cin`和`cout`会使IDE发出警告  |
| char16_t      | 无符号，长度16位，在字符或字符串前使用`u`（<font color=red>注意小写</font>）修饰，可转换成Unicode字符                                            |
| char32_t      | 无符号，长度32位，在字符或字符串前使用`U`（<font color=red>注意大写</font>）修饰，可转换成Unicode字符                                            |
| string        | 以双引号`"some_string"`表示一个字符串，可以使用`+`以及`+=`进行字符串拼接，特殊字符同样需要进行转义，或是使用`R"(some_string)"`来表示原始的字符串 |

#### 布尔值

| 类型 | 说明                                                           |
| :--- | :------------------------------------------------------------- |
| bool | 目前只有true和false两个值，将零解释成false，将非零值解释成true |

### 基本类型转换

C++对于基本类型转换提供了两种方式，一种是自动的，另一种是强制的。

#### 自动转换

对于自动转换，C++在以下三个场景中遵守相应的规则：

+ 初始化和赋值
短长度类型的值被赋给长长度类型的变量是允许的（比如int类型的值赋给double类型的变量），但是反过来就很容易引起问题，比如造成溢出、精度丢失等。

+ 表达式的转换
表达式中会自动执行类型提升操作，亦即将短长度类型转换成长长度类型，将低级别操作数转换成高级别操作数（这里就涉及到汇编和机器码的问题了）。

+ 传递参数的转换
函数中传递参数也同样会执行类型提升的操作。

#### 强制转换

强制转换通常可以采用下面两种格式：

```
//C语言风格
(type) value

//C++风格
type(value)
```
C++还有四个强制转换运算符，但是它们的使用要求更为严格：

|运算符|说明|
|:--|:--|
|const_cast<type>(value)|用于修改类型的const/volatile属性。除了const或volatile属性之外，目标类型必须与源类型相同。这种类型的转换主要是用来操作所传对象的const属性，可以加上const属性，也可以去掉const属性
|dynamic_cast<type>(value)|在运行时执行转换，验证转换的有效性。如果转换未执行，则转换失败，value被判定为null。dynamic_cast执行动态转换时，type必须是类的指针、类的引用或者void*，value的类型与type保持一致
|reinterpret_cast<type>(value)|把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针
|static_cast<type>(value)|执行非动态转换，没有运行时类检查来保证转换的安全性




