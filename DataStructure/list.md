## 线性表

线性表（linear list）是最为简单常用的一种数据结构，它是若干个具有**相同特性**的数据元素的<u>有限</u>序列。在稍微复杂的线性表中，一个由若干数据项组成的数据元素被称为**记录**，含有大量记录的线性表称为**文件**。

线性表的长度是指其所包含的<u>元素个数</u>，长度为0的线性表被称为空表。线性表的第一个元素称为<u>表头</u>，最后一个元素被称为<u>表尾</u>。

线性表是一个灵活的数据结构，线性表的数据元素除了可以被访问，还可以被插入和被删除。

### 顺序表

顺序表使用<font color=red><u>一组地址连续的存储单元依次存储数据元素</u></font>，最典型的应用就是数组。

顺序表中第 *i* 个元素相对于表头的位置的表示方法为：

$$LOC(a_i) = LOC(a_1) + (i - 1) × l$$

其中 $l$ 表示每个数据元素所占用的存储单元个数。

相邻数据元素的位置表示方法为：

$$LOC(a_{i+1}) = LOC(a_i) + l$$

顺序表的存储方式决定了它里面的数据元素可以被**随机存取**，只要知道表头位置即可直接定位到目标元素，对于读取某个数据元素之类的操作是非常方便的。但是在进行插入或删除这类的操作时，如果操作的元素位于表尾，那么无疑是最方便的，不需要移动任何元素，时间复杂度为$O(1)$；而在最坏的情况下（即在表头插入或删除元素），顺序表要对内部的几乎所有数据元素进行移动，平均来看这两种操作也都需要移动一半的元素，会消耗较多的执行时间，时间复杂度为$O(N)$。为了避免顺序表在增删方面时间开销过大问题，就要使用一种新的线性表——链表。

### 链表

#### 线性链表

线性链表也称简单链表，它使用<font color=red><u>一组任意的（可以连续也可以不连续）存储单元存储数据元素</u></font>。

在线性链表中，数据元素被称为**结点**，它包含两个组成部分：一个是<u>存储数据元素信息</u>的**数据域**，另一个是<u>存储直接后继位置</u>的**指针域**（最后一个数据元素该项为空）。由于线性链表中的结点只包含**一个**指针域，故又被称为<u>单链表</u>。

<font color=blue><u>注意：线性链表中的第一个结点不能称为“头结点”，头结点附设于第一个结点之前，用于指示真正的第一个结点。头结点的数据域可以不存储任何信息，也可以存储跟线性链表相关的附加信息。</u></font>

线性链表的存储方式决定了它里面的数据元素不能像顺序表一样随机存取，与线性表相反，如果要获取表长或读取某个数据元素，一般只能基于**遍历**操作，时间复杂度为$O(N)$；但是进行插入或删除操作却很简便，只要修改指针域的指向即可，时间复杂度就变成了$O(1)$，具体操作方式为：

① 插入：在元素 *a* 与元素 *b* 之间插入元素 *i* ，先生成元素 *i* ，再将 *i*  的指针域指向 *b* ，最后将 *a*  的指针域指向 *i* 。

② 删除：在元素 *a*  -> 元素 *i*  -> 元素 *b* 中删除 *i* ，首先将 *a* 的指针域指向 *b* ，然后将 *i* 删除并释放掉。

在不设指针的高级语言当中，线性链表借用<u>一维数组</u>来进行描述，这种链表被称为**静态链表**。在这种情况下，使用"游标"替代指针来指示下一个结点位置。数组下标为0的元素依然是头结点，其游标指示的是下标为1的链表第一个结点，而<u>最后一个结点的游标又指回头结点</u>。

在线性链表中，若最后一个结点的指针域指回头结点，使得链表形成一个环，则可称为循环链表。

#### 双向链表

双向链表是一种<font color=red>结点包含两个指针域，分别指示前驱结点和后继结点</font>的链表。双向链表克服了线性链表结点无法直接寻找前驱结点的缺陷。

双向链表在插入和删除数据元素时，都需要同时修改两个方向的指针域，每个方向的修改方式跟线性链表类似。

#### 多重链表

多重链表是指链表中存在<u>同时隶属于多个链</u>的结点，这些结点包含多个指向隶属于**不同**链表的结点的指针域，如树、图等更为复杂的数据结构。双向链表中的结点虽然包含两个指针域，但均是指向**同一**链表中的前驱结点和后继结点，不能称为多重链表。换言之，**多重链表一定是结点包含多个指针域的链表，但是结点包含多个指针域的链表不一定是多重链表，可能只是双向链表而已**。

### 广义表

广义表是线性表的推广（故又称作$lists$，**列表**），对于线性表而言，表内元素都是基本的**单**元素，而广义表中的元素不仅可以是单元素（称之为**原子**），还可以是另一个广义表（称之为**子表**）。当广义表非空时，其第一个元素称为**表头**，其余元素称为**表尾**。

广义表有三个重要的性质：

* 广义表的元素可以是子表，子表的元素仍然可以是子表，如此可无限类推；

* 一个列表可以为其他列表所共享；

* 列表可以是递归的，即列表中的子表可以是自身。

广义表的元素特性决定了其难以采用顺序存储结构表示，因此使用链式存储就成了自然而然的选择。

采用了链式存储结构的广义表，在结点的结构上被划分为**表结点**和**原子结点**两类。一种常见的结构表示方法为：一个表结点的结构分为<u>标志域、表头指针域以及表尾指针域</u>，而一个原子结点的结构只有<u>标志域和值域</u>。另一种常见的表示方法在前面一种的基础上，给原子结点添加了指针域，用于指示下一个结点。

## 数组

### 基本概念

数组是一种常见的数据结构，一维数组可以视为定长的线性表，$n$ 维数组则可视为线性表的推广。数组一旦被定义，其维数和维界就不再改变，因此除了结构的初始化与销毁之外，数组只有存取和修改元素的操作。

数组一般不作插入或删除操作，亦即内部的数据元素个数以及它们之间的关系通常不会发生变动，因此自然而然会采用顺序存储结构。采用顺序存储结构就意味着只要知道数组的首个元素位置，便可以使用计算的方式来获得任意元素位置，从而实现随机存取。

以二维数组为例，根据以列或以行为**主序**，可以将存储方式划分为两类：一个 $m$ 行 $n$ 列的二维数组，既可以视作由 $n$ 个各自包含 $m$ 个元素的"列向量"组成（以列序为主序），也可以视作由 $m$ 个各自包含 $n$ 个元素的"行向量"组成（以行序为主序）。 

### 矩阵的压缩存储

通常，在使用高级语言编制程序时，都是用二维数组来存储矩阵元。而一些阶数很高的矩阵内部往往包含许多值相同元素或是零元素，这就需要对其进行**压缩**。

所谓的矩阵压缩存储，是指<u><font color=red>为多个具有相同值的元只分配一个存储空间，而对零元不分配空间。</font></u>

#### 特殊矩阵

在计算机科学领域中，常见的特殊矩阵主要是对称矩阵、三角矩阵以及对角矩阵。这三类矩阵都可以压缩存储到一个**一维**数组中，而且每个非零元都能在其中找到对应关系。

对于 *n* 阶对称矩阵和三角矩阵，通常使用一个包含 $\frac{n(n+1)}{2}$ 个存储空间的一维数组 $sa$ 来存储非零元，且 $sa[k]$和矩阵元 $a_{ij}$ 之间存在以下一一对应的关系：

$$k=\begin{cases}  
\frac{i(i-1)}{2} + j - 1 & (i \ge j) \\
\\
\frac{j(j-1)}{2} + i - 1 & (i < j) \\
\end{cases}$$

而对于**所有非零元都集中在以主对角线为中心的带状区域**的对角矩阵，也可以采用类似的方法将矩阵元压缩到一维数组中。

#### 稀疏矩阵

所谓的稀疏矩阵，通常是指非零元在矩阵中的占比不超过5%（亦即<u>稀疏因子</u>不超过0.05）的矩阵。对于稀疏矩阵的压缩，其基本思想为使用包含非零元的值以及行列位置的 **三元组( $i, j, a_{ij}$)** 进行压缩存储，由此引出以下三种不同的压缩存储方法。

+ **1.三元组顺序表**

三元组顺序表又称有序的双下标法，其特点为：非零元在表中按**行序**有序存储，因此便于进行依行顺序处理的矩阵运算。但如果需要按照行号存取某一行的非零元，则需从头开始进行查找。

+ **2.行逻辑链接的顺序表**

行逻辑链接的顺序表是对三元组顺序表的一种改进，它将指示“行”信息的数组固定在矩阵的存储结构中，用于标识**每一行的第一个非零元的位置**，从而实现对任意一行非零元的随机存取。

+ **3.十字链表**

当矩阵的非零元**个数和位置在操作过程中变化较大**时，不宜采用顺序存储结构，而是采用链式存储结构。所谓的十字链表是指，链表中每个非零元都可用包含5个域的结点来表示：在三元组的基础上增加用于指示**同一行**下一个非零元的<u>向右域</u>，以及用于指示**同一列**下一个非零元的<u>向下域</u>。

在这种情况下，每个结点即既是某个行链表的结点，又是某个列链表的结点，整个矩阵构成了一个十字交叉的链表，这就是十字链表的名称由来。