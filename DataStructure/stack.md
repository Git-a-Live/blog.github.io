栈（stack）和队列（queue）本质上都是一类**操作受限**的线性表，尽管如此，它们还是具备与线性表大不相同的特性，因此从数据类型的角度来说，可以被单独划分出来讨论。

## 栈

栈是一种<font color=red><u>限定仅在表尾进行插入或删除操作</u></font>的线性表，其表尾被称作**栈顶**，表头被称为**栈底**。位于栈顶的元素通常是唯一的可见元素。

栈的修改是按照**后进先出**原则进行的，因而是一种LIFO（last in first out）结构。向栈内插入元素称为<u>入栈</u>，删除元素则是<u>出栈</u>。入栈和出栈可以交替执行。

栈可以利用顺序表（通常就是用一维数组）或链表实现。顺序表的表尾自然就是栈顶。但是链表通常建议用**表头**作为栈顶，其原因在于如果使用单向链表来实现栈，在执行删除操作时，删掉表尾需要先进行遍历，找到表尾的前驱结点之后才能执行真正的删除操作，时间开销比操作表头要大得多。 

>注意，基于数组实现的栈可能是更流行的解决方案，因为出入栈的操作能够以非常快的常数时间运行，在一些将栈操作作为指令系统一部分的机器上，这种实现方案比链表更为便捷。

当栈内数据元素个数为0个时，称该栈为空栈。对于顺序表，当表内有0个数据元素时为空；对于链表，当表内头结点指向Null或本身时为空。


## 队列

队列是一种<font color=red><u>限定仅在一端插入元素，而在另一端删除元素</u></font>的线性表，插入元素的一端称为**队尾**（rear），删除元素的一端称为**队头**（front）。它遵循的是**先进先出**原则，是一种FIFO（first in first out）结构。

**循环队列**是队列的顺序表示和实现形式。循环队列主要是为了解决使用数组时因插入删除元素可能带来的<u>数组越界</u>和<u>扩充不便</u>问题，适用于队列长度明确的场景。对于循环队列而言，头指针指向的下一个位置是尾指针时，队列为空；尾指针指向的下一个位置是"满"标识位或者头指针时，队列为满。

**链队列**则是队列的链式表示和实现形式。链队列实际上就是单链表的一种，因此其插入和删除的操作与单链表基本相同，只不过链队列增设了头尾指针。向链队列的队尾插入结点，只需要把上一个"尾结点"的指针和尾指针改成指向新插入的结点；从链队列删除头元素，通常只要把头结点的指针指向头元素的下一个元素。当队列中最后一个元素被删除后，尾指针也随之丢失，需要重新赋值一个尾指针指向头结点。

**双端队列**（deque）是一种两端都可以执行插入和删除操作的队列，但是实际用处并没有栈和队列来得多。

## 堆

**堆**（heap）是一种<font color=red><u>优先</u></font>队列，在实际应用中通常以"树"的形式实现。堆内元素不是按照进入队列的先后顺序，而是按照**权重**来进行排序。堆的实现方法通常有四种：

> **无序数组**

<u>任意新增</u>的元素总是插入尾部（时间复杂度为$O(1)$），查找具备最大（小）权重元素需要遍历（时间复杂度为$O(n)$），删除操作需要移动大量元素（时间复杂度为$O(n)$）。

> **有序数组**

根据元素的权重大小，与数组位置一一对应插入数组（时间复杂度为$O(n)$或$O(log_2\ n)$），由于元素顺序与数组位置一一对应，在出队的时候总是删除队尾权重最小的元素（时间复杂度为$O(1)$）。

> **无序链表**

元素总是插入链表头部（时间复杂度为$O(1)$），查找最大（小）权重的元素需要遍历（时间复杂度为$O(n)$），出队删除结点的操作跟单链表类似（时间复杂度为$O(1)$）。

> **有序链表**

根据元素的权重大小，在链表中赋予插入顺序（时间复杂度为 $O(n)$），由于链表中已对元素进行排序，权重与顺序对应，通常出队只需要删除队首或队尾元素（时间复杂度为$O(1)$）。