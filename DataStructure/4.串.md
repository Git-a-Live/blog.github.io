## 一、串类型的定义

串（string）是指由若干**字符**组成的有限序列，通常在高级语言中用`""`或`''`将这些字符括起来用于标识字符串，**引号本身不属于字符串**（字符串中的引号还要加上`\`进行转义）。空串是指<font color=red><u>不包含任何字符</u></font>的串；空格串是指<font color=green><u>由至少一个空格组成</u></font>的串；子串是指串中<u><font color=blue>任意连续字符</font></u>组成的子序列。

通常称串中字符的数目为串的**长度**，字符在序列中的序号为串中的**位置**，子串首个字符的位置即为子串之位置。

两个字符串<u>只有在长度以及对应位置字符均相等</u>的情况下才能称为相等。

## 二、表示与实现

### 定长顺序存储

定长顺序存储是指<u><font color=blue>按照预定义的大小，为每个定义的串变量分配一个**固定长度**的存储区，用一组地址连续的存储单元存储串值的字符序列</font></u>。

串的实际长度只要在预定义长度范围内都是允许的，而超过预定长度的串会发生**截断**，即舍去预定义长度范围以外的所有串值。只要使用定长顺序存储，截断就会发生在任何操作中，因而成为一个突出的弊端。

定长顺序存储的串操作基于"**字符序列的复制**"，因此操作的时间复杂度主要取决于字符序列的长度。

### 堆分配存储

为了克服定长顺序存储的截断弊端，又发展出了堆分配存储。堆分配存储是指<u><font color=orange>将串值字符序列存放在一组地址连续的存储单元里，但是存储空间可以由动态分配获得</font></u>。这里的"堆"与队列中的"堆"有所区别，是指C语言中的自由存储区。

在C语言中，自由存储区"堆"可以利用动态分配函数`malloc()`和`free()`来管理，前者可以为每个新产生的串分配一块实际串长所需的存储空间，若分配成功则返回一个指向起始地址的指针作为串的基址。

### 块链存储

块链存储是指<u><font color=green>用链表结点（又称作块）存储串值字符（每个结点存储若干个），并设置头尾指针以分别指示串的起始位置和结束位置以及串长</font></u>。

每个结点所存储的字符数目被称为结点的大小，结点大小大于1时，最后一个结点不一定会被串值占满，因而使用非串值字符填充。结点大小的选择直接影响串处理的效率，由此引申出**存储密度**的概念：

$$D_{storage} = \frac{Bits_{string}}{Bits_{alloc}}$$

存储密度越小，运算处理越方便，但是存储占用量大。

总体来说，块链存储占用存储量大且操作复杂，灵活性上不如定长顺序存储和堆分配存储。

## 三、模式匹配算法

### 基本思想

从主串的第 $n$ 个（$n \ge 1$）字符起和模式的第一个字符进行比较，若相等则继续逐个比较后续字符；否则从主串的下一个字符起再重新和模式的字符比较。以此类推，直到模式中的每个字符依次和主串中的一个子序列相等，则称匹配成功，否则为匹配失败。这种算法在模式与主串之间存在**较少"部分匹配"** 的情形下可以使用，反之效率会大幅降低。

上述算法可以得到第一个结论：<u><font color=red>若主串长度小于模式长度，则匹配必然失败</font></u>。

### KMP算法

为了解决模式与主串之间存在大量"部分匹配"，导致基本算法效率大幅下降的问题，一种改进的算法——KMP算法被提出。KMP算法的改进部分在于：

> 每当一趟匹配过程中出现字符比较不等时，不需回溯指针，而是利用已经得到的"部分匹配"的结果将模式向右“滑动”尽可能远的一段距离后，继续进行比较。

由此可以得出第二个结论：<u><font color=red>"滑动"一定距离后，若主串剩余长度小于模式长度，则匹配必然失败</font></u>。

现在问题变成："滑动"多少距离才算合适？这就是KMP算法最核心的部分。

#### 部分匹配表PMT

为了获得合适的"滑动"距离，KMP算法引入了一个被称作**部分模式匹配表**（Partial Match Table）的数组。以字符串`abababca`为例，其PMT的组成如下表所示：

|         |       |       |       |       |       |       |       |       |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| `char`  |   a   |   b   |   a   |   b   |   a   |   b   |   c   |   a   |
| `index` |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| `value` |   0   |   0   |   1   |   2   |   3   |   4   |   0   |   1   |

表中的`char`部分，自左向右就是字符串中的各个字符，`index`即为串中各个字符的位置，`value`代表的是<u>从表中第一个字符到**当前字符**所组成的一个字符串子序列，其**前缀**部分同它的**后缀**部分的<font color=red>做交集运算后得到的<font color=blue>最大</font>字符串长度</font></u>。

所谓一个字符串的前缀部分，是指<u>包含该字符串 ***第一个*** 字符，且长度小于该字符串的一个子序列</u>，后缀部分则是指<u>包含该字符串 ***最后一个*** 字符，且长度小于该字符串的一个子序列</u>。

在PMT中，`value`可以通过编写一个value函数计算得到。

#### PMT的运用

若以`abababca`为模式，以`ababababca`为主字符串，另设指针 *i* 指示主字符串当前匹配位置，指针 *j* 指示模式当前匹配位置。二者进行第一轮匹配时，结果如下：

|       |       |       |       |       |       |  $i$  |       |       |       |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |       |       |       |       |       |   ⬇️   |       |       |       |
|  $0$  |  $1$  |  $2$  |  $3$  |  $4$  |  $5$  |  $6$  |  $7$  |  $8$  |  $9$  |
|  *a*  |  *b*  | *`a`* | *`b`* | *`a`* | *`b`* |  *a*  |  *b*  |  *c*  |  *a*  |
| *`a`* | *`b`* | *`a`* | *`b`* |  *a*  |  *b*  |  *c*  |  *a*  |       |       |
|  $0$  |  $1$  |  $2$  |  $3$  |  $4$  |  $5$  |  $6$  |  $7$  |
|       |       |       |       |       |       |   ⬆️   |       |       |       |
|       |       |       |       |       |       |  $j$  |       |       |       |

从上面的结果可以获得几个重要的结论：

<font color=red>（1）主字符串中，$0$ 到 $i - 1$ 位子序列与模式的 $0$ 到 $j - 1$ 位相同；

（2）模式 $0$ 到 $j - 1$ 位在PMT中对应value为4，表明模式的4位前缀与子序列的4位后缀相同；

（3）根据（2）所得到的信息，模式应向右滑动使得其前缀与子序列后缀对齐；

（4）在完成（3）的操作之后，指针 $j$ 即指向新的模式串字符，下一轮匹配将从此处开始。</font>

从结论（3）可以得到第二轮匹配结果：

|       |       |       |       |       |       |  $i$  |       |       |       |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|       |       |       |       |       |       |   ⬇️   |       |       |       |
|  $0$  |  $1$  |  $2$  |  $3$  |  $4$  |  $5$  |  $6$  |  $7$  |  $8$  |  $9$  |
|  *a*  |  *b*  | *`a`* | *`b`* | *`a`* | *`b`* |  *a*  |  *b*  |  *c*  |  *a*  |
|       |       | *`a`* | *`b`* | *`a`* | *`b`* |  *a*  |  *b*  |  *c*  |  *a*  |
|       |       |  $0$  |  $1$  |  $2$  |  $3$  |  $4$  |  $5$  |  $6$  |  $7$  |
|       |       |       |       |       |       |   ⬆️   |       |       |       |
|       |       |       |       |       |       |  $j$  |       |       |       |

由结论（4），可以将抽象的"滑动多少距离"转化为更具体的问题：<font color=orange>指针 $j$ 会指向哪个模式串字符</font>？

#### next函数的运用

为了解决"指针 *j* 会指向哪个模式串字符"的问题，需要引入一个next函数，该函数可以计算并返回当前指针 *j* 所对应的下一个模式串字符位置，同时对PMT进行修改，得到下面的形式：

|         |       |       |       |       |       |       |       |       |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| `char`  |   a   |   b   |   a   |   b   |   a   |   b   |   c   |   a   |
| `index` |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| `value` |   0   |   0   |   1   |   2   |   3   |   4   |   0   |   1   |
| `next`  |   0   |   0   |   0   |   1   |   2   |   3   |   4   |   0   |

next函数的基本思想为：若在匹配过程中主字符串字符与模式串字符匹配，则指针 $i$ 与指针 $j$ 分别 $+1$，否则指针 $j$ 回溯到 $next(j)$ 所对应的字符位置，再与指针 $i$ 对应的字符比较，并以此类推。