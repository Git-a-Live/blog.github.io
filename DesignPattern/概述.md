## 一、设计模式的目的

设计模式的出现和使用，其目的在于**复用**以往成功的设计方案，而不必总是从头开始解决问题。使用设计模式是为了提高代码复用性和可维护性，应当灵活、恰当使用，**切勿过度设计**。

## 二、设计模式的基本要素

`1.模式名称`

模式名称用于描述一个设计模式的问题、解决方案以及效果。

`2.问题`

描述何时使用模式。

`3.解决方案`

描述该设计模式的组成部分，或者说提供一个模版。

`4.效果`

描述该设计模式的使用对于程序性能的影响。

## 三、面向对象软件设计的基本原则

**`1.Single Responsibility Principle（单一职责原则）`**

*抽象说法*：一个类应该只有一个发生变化的原因。

*解释*：一个对象不应该承担太多职责，包罗万象的“万金油”是一种愚蠢的设计，会造成代码冗余和资源浪费，提高复杂度和耦合度，降低可读性和可维护性。

**`2.Open Closed Principle（开闭原则）`**

*抽象说法*：一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。

*解释*：尽可能利用抽象、继承、多态等面向对象特性，而不要直接修改最顶层对象（基类），避免“牵一发而动全身”，造成程序内有更多地方为了适应这种修改而被迫跟着修改。

**`3.Liskov Substitution Principle（里氏替换原则）`**

*抽象说法*：所有引用基类的地方必须能透明地使用其子类的对象。

*解释*：可以使用父类的地方同样也可以使用其子类，尽量使用子类代替父类来完成相应的职责，避免发生违反开闭原则的情况。

**`4.Law of Demeter（迪米特法则）`**

*抽象说法*：只与你的直接朋友交谈，不跟“陌生人”说话。

*解释*：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。这么做的目的在于降低类之间的耦合度，提高模块的相对独立性。需要直接通信的实体通常包括：

(1) 当前对象本身
(2) 以参数形式传入到当前对象方法中的对象
(3) 当前对象的成员对象，以及这些成员对象可能包含的所有元素
(4) 当前对象所创建的对象

**`5.Interface Segregation Principle（接口隔离原则）`**

*抽象说法*：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。

*解释*：每一个接口（包括具体的接口方法和抽象类等）应该承担独立的角色，不做“分外之事”；每个对象都不需要实现不必要的接口，也不需要对外提供不必要的接口。

**`6.Dependence Inversion Principle（依赖倒置原则）`**

*抽象说法*：上层模块不应该依赖底层模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。

*解释*：要面向接口编程，不要面向实现编程。在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

## 四、设计模式的基本分类

设计模式可以大致划分为三大类型：

### 1.创建型

创建型模式用于**抽象实例化过程**，主要特点是“将对象的创建与使用分离”。这类设计模式又可以分为**类创建**和**对象创建**两个方面，包含*Prototype、Singleton、Builder、Abstract Factory*以及*Factory Method*等五种设计模式。

### 2.结构型

结构型模式用于描述如何**将类或对象按某种布局组成更大的结构**。它分为**类结构型**模式和**对象结构型**模式，前者采用**继承**机制来组织接口和类，后者釆用**组合或聚合**来组合对象。这类设计模式包含*Adapter、Bridge、Composite、Decorator、Facade、FlyWeight*以及*Proxy*等七种设计模式。

### 3.行为型

行为型模式用于描述程序在运行时复杂的流程控制，即描述**多个类或对象之间怎样相互协作共同完成**单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。行为型模式分为**类行为**模式和**对象行为**模式，前者采用**继承**机制来在类间分配行为，后者采用**组合或聚合**在对象间分配行为。它包含*Chain of Responsibility、Command、Interpreter、Interator、Mediator、Memento、Observer、State、Strategy、Template Method*以及*Visitor*等十一种设计模式。