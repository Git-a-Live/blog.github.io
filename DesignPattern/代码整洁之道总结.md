## 注释

+ **不恰当的信息**

通常情况下，**作者**、**最后修改时间**以及**SPR数**等元数据不该在注释中出现，注释只应该描述有关代码和设计的**技术性信息**，尤其是“<u>为什么这么做</u>”。至于“做了什么”和“怎么做”，应尽可能让代码实现自解释。此外，注释应当准确简明，语句通顺，无错别字或拼写错误。特别要注意，注释中不要出现各种来自其他语言的标签，IDE通常并不会帮助代码的阅读者解析渲染这些标签，除了增大认知负担之外毫无用处。

+ **废弃注释**

过时、无关或不正确的注释就是废弃的注释。这类注释有可能会误导自己以及其他开发者，因此一旦发现代码中存在废弃的注释，应当尽快更新或删除掉。

+ **冗余注释**

如果代码自身能够通过变量命名以及方法签名等方式实现比较充分的自我描述，那么就没有必要为那些显而易见的东西添加多余的注释，注释应当谈及代码自身没有提到的内容，具体参考第一条。

+ **废弃代码**

在正式项目中，已经被注释掉的代码通常不会有机会再被恢复使用。随着时间的推移，这些废弃代码与系统越来越没有关系，除了给源文件带来不必要的负担之外，还会白白占据开发者显示器的空间。<font color=red>善用版本控制系统，大胆删除被废弃的代码，不要让它们继续在项目里腐烂发臭了！</font>

## 函数

+ **过多的参数**

一个函数不要有三个以上的入参。如果出现三个以上入参，那么就要考虑某些入参是不是可以通过其他方式在函数内部就能获得，而非只是简单地从外部传入，或是将经常一起出现的参数们封装到同一个对象里。

+ **输出参数**

输出参数是违反直觉的。参数通常被期望用于输入而非输出，如果函数非要修改什么东西的状态，那就修改它所在对象的状态，而不是把修改结果传递出去，这是没必要的。

+ **标识参数**

布尔值参数大声宣告函数做了不止一件事。它们令人迷惑，应当消灭掉。如果只是考虑有一小部分代码需要区分二元情形，从而采取不同的措施，那倒也罢了；最恐怖的莫过于两种情形的业务逻辑完全没有重合可复用的地方，却硬要通过标识参数把它们整合到一个函数当中，简直骇人听闻。

+ **死函数**

永不被调用的方法应当丢弃，保留死代码纯属浪费。还是那句话，善用版本控制系统，大胆删除被废弃的代码。

## 命名

+ **采取描述性名称**

无论是变量、常量、函数还是类，都应当赋予它们有意义的、一目了然的名称。尽管胡乱起名不一定影响代码的编译运行，但是对于阅读代码的人来说，乱七八糟让人摸不着头脑的命名无疑是非常令人火大的。采取描述性名称的好处在于，代码阅读者不需要劳心费力地去阅读上下文揣测“这玩意儿到底是什么”，只需要看到名字即可理解这个对象是什么以及具有何种用处。

除了一开始就认真取名之外，还需要注意一件事，那就是随着项目的迭代演化，一些命名可能已经不符合实际情况了，所以需要经常性地评估命名是否依然恰当。不合适的命名跟垃圾注释一样糟糕，只会令人感到迷惑甚至恼火。

+ **“名副其实”**

命名要跟抽象层级相符。例如一个函数通常不会被命名为xxxManager或xxxUtils，而一个类也不会命名为GetSomething或者SetSomething等等，因为这并不符合长久以来的认知习惯。毫无疑问，抽象层次越高，命名时概括性也越强，反之就要准确地反映出具体细节，这可能会带来比较长的名称，不过总比写大段注释要好。

+ **使用标准命名法**

不同的开发语言和开发团队，通常会采用不同的命名法。开发者在一开始就应当很好地遵循这些命名规范，即便这些规范与以往自己所接触使用的不一样——当然，包含类型或作用范围信息的“匈牙利命名法”除外，它已经不适合在IDE丰富、可靠的2022年继续使用下去了。

## 测试

+ **充分测试**

一套测试应该测到所有可能失败的东西，只要还有没被测试探测过的条件（特别是那些可能会引发错误的边界条件），或是还有没被验证过的计算，测试就还不够。

+ **使用覆盖率工具**

覆盖率工具能汇报测试策略中的缺口。使用覆盖率工具能更容易地找到测试不足的模块、类和函数。多数IDE都能给出直观的指示，用绿色标记测试覆盖了的代码行，而未覆盖的代码行则是红色。这样就能又快又容易地找到尚未检测过的if或catch语句。

+ **全面测试相近的缺陷**

缺陷趋向于扎堆。在某个函数中发现一个缺陷时，最好全面测试那个函数，因为这样一来所暴露的缺陷可能不止一个。

+ **测试失败的模式有启发性**

有时候，通过找到测试用例失败的模式，可以诊断出问题所在，这也是尽可能编写足够完整的测试用例的理由之一。完整的测试用例，按照合理的顺序排列就能暴露出模式。此外，查看被已通过或未通过的测试所执行的代码，往往能发现失败的测试为何会失败的线索。

+ **快速测试**

竭尽所能让测试够快，这样即便时间紧迫也能将测试尽可能多地覆盖到整个项目。

## 其他问题

+ **明显的行为未被实现**

遵循“最小惊异原则”（The Principle of Least Surprise），函数或类应该实现其他开发者有理由期待的行为。如果明显的行为未被实现，那么读者和用户就不能再依靠他们对函数名称的直觉，也不再信任作者，而是不得不阅读代码细节乃至弃用这些不符合自己需要的代码。

+ **解耦！解耦！！解耦！！！**

各种设计模式和编程方法论的提出，其中一个重要的目的就是确保代码之间保持较低的耦合度，不会牵一发而动全身。没人希望改完一处代码，发现还有成百上千个跟它有关联的位置等待进一步的修改。不相互依赖的东西不该耦合，尤其是将变量、常量、方法乃至类不恰当地放在临时方便的位置，这是一种漫不经心的偷懒行为。

+ **遵守编码规范和约定**

每个团队都应遵循基于通用行业规范的一套编码标准，比如在何处声明实体变量，如何命名类、方法以及变量等等。标准和约定之所以有效，是因为它们得到严格落实。仅仅在文档中描述，还不足以发挥作用，必须让代码提供范例。最典型的一种操作便是“结构甚于约定”，强制性的结构——例如接口的实现——比非强制性的约定具备更有效的约束力。一个开发者或许可以随便写一大堆条件分支语句，但是却不能随意更改某个接口确立的代码结构。

+ **不要掩蔽时序耦合**

如果有一段业务逻辑需要强调各个方法的调用次序，比如先调用方法A，接着调用方法B，然后调用方法C，那么代码中就应该反映出这种次序的强制性，以避免其他开发者随意打乱调用次序引发问题。一种典型的方式就是，**每个方法都产生出下一个方法所需的结果**，这样一来就没理由不按顺序调用了。